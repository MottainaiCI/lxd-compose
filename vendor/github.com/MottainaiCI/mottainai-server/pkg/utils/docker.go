/*

Copyright (C) 2017-2018  Ettore Di Giacinto <mudler@gentoo.org>
Credits goes also to Gogs authors, some code portions and re-implemented design
are also coming from the Gogs project, which is using the go-macaron framework
and was really source of ispiration. Kudos to them!

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <http://www.gnu.org/licenses/>.

*/

package utils

import (
	"bufio"
	"io"
	"os"

	docker "github.com/fsouza/go-dockerclient"
	log "gopkg.in/clog.v1"
)

// Config represent the yaml configuration file
type Config struct {
	// Firewall_network_rules map[string]Options `yaml:"repository"`
	Repository            string `yaml:"repository"`
	RepositoryStripped    string
	DockerImage           string              `yaml:"docker_image"`
	DockerSkipPull        bool                `yaml:"docker_skip_pull"`
	DockerCommit          bool                `yaml:"docker_commit"`
	Commit                map[string]string   `yaml:"commit"`
	DockerImageEntrypoint []string            `yaml:"docker_image_entrypoint"`
	PreProcessor          string              `yaml:"preprocessor"`
	Provisioner           map[string][]string `yaml:"provisioner"`
	PostProcessor         []string            `yaml:"postprocessors"`
	PollTime              int                 `yaml:"polltime"`
	Artifacts             string              `yaml:"artifacts_dir"`
	SeparateArtifacts     bool                `yaml:"separate_artifacts"`
	LogDir                string              `yaml:"log_dir"`
	LogPerm               int                 `yaml:"logfile_perm"`
	Env                   []string            `yaml:"env"`
	Args                  []string            `yaml:"args"`
	TmpDir                string              `yaml:"tmpdir"`
	Volumes               []string            `yaml:"volumes"`
	WorkDir               string
}

// attach attaches to the container
func ContainerOutputAttach(callback func(string), client *docker.Client, container *docker.Container) error {
	r, w := io.Pipe()
	options := docker.AttachToContainerOptions{
		Container:    container.ID,
		OutputStream: w,
		ErrorStream:  w,
		Stream:       true,
		Stdout:       true,
		Stderr:       true,
		Logs:         true,
	}
	log.Info("Attaching to container " + container.ID)
	go client.AttachToContainer(options)
	go func(reader io.Reader, container *docker.Container) {
		scanner := bufio.NewScanner(reader)
		for scanner.Scan() {
			callback(scanner.Text())
		}
		if err := scanner.Err(); err != nil {
			log.Info("There was an error with the scanner in attached container:" + err.Error())
		}
	}(r, container)
	return nil
}

// ContainerDeploy Deploys a container  wich option are specified by config. Optional arguments are passed, typicallyf autogenerated by processor/preprocessor
func ContainerDeploy(config *Config, args []string, volumes []string, head string) (bool, error) {
	endpoint := "unix:///var/run/docker.sock"
	client, _ := docker.NewClient(endpoint)
	var containerconfig *docker.Config
	var err error
	var status int
	DockerImage := config.DockerImage

	if config.DockerSkipPull == false {
		log.Info("Pulling image: %s\n", DockerImage)

		if err := client.PullImage(docker.PullImageOptions{Repository: DockerImage}, docker.AuthConfiguration{}); err != nil {
			log.Info("error pulling %s image: %s\n", DockerImage, err)
			return false, err
		}
	}
	combinedArgs := append(args, config.Args...)
	if len(config.DockerImageEntrypoint) == 0 {
		containerconfig = &docker.Config{
			Image: DockerImage,
			Cmd:   combinedArgs,
			Env:   config.Env,
		}
	} else {
		containerconfig = &docker.Config{
			Image:      DockerImage,
			Cmd:        combinedArgs,
			Env:        config.Env,
			Entrypoint: config.DockerImageEntrypoint,
		}
	}

	container, err := client.CreateContainer(docker.CreateContainerOptions{
		Config: containerconfig,
	})

	ContainerOutputAttach(func(s string) { log.Info("Out: %v", s) }, client, container)
	// Cleanup when done
	defer func() {
		if config.DockerCommit == true {
			repository, repositoryok := config.Commit["repository"]
			tag, tagok := config.Commit["tag"]
			message, messageok := config.Commit["message"]
			author, authorok := config.Commit["author"]
			on, onok := config.Commit["on"]
			if tagok == false {
				tag = "latest"
			}
			if messageok == false {
				message = ""
			}
			if authorok == false {
				author = ""
			}
			if onok == false {
				on = "always"
			}
			log.Info("Committing to " + repository + " \n\tTag:" + tag + " Message: " + message + " Author: " + author)

			if repositoryok {

				if onok {
					switch on {
					case "success":
						if status == int(0) {
							Image, err := client.CommitContainer(docker.CommitContainerOptions{
								Container:  container.ID,
								Repository: repository,
								Message:    message,
								Author:     author,
								Tag:        tag,
								Run:        containerconfig,
							})
							if err != nil {
								log.Error(2, "Image commit failed: %v", err)
							} else {
								log.Info("Image committed to ID: " + Image.ID)
							}
						}
					default:
						Image, err := client.CommitContainer(docker.CommitContainerOptions{
							Container:  container.ID,
							Repository: repository,
							Message:    message,
							Author:     author,
							Tag:        tag,
							Run:        containerconfig,
						})
						if err != nil {
							log.Error(2, "Image commit failed: %v", err)
						} else {
							log.Info("Image committed to ID: " + Image.ID)
						}
					}
				} else {
					Image, err := client.CommitContainer(docker.CommitContainerOptions{
						Container:  container.ID,
						Repository: repository,
						Message:    message,
						Author:     author,
						Tag:        tag,
						Run:        containerconfig,
					})
					if err != nil {
						log.Error(2, "Image commit failed: %v", err)
					} else {
						log.Info("Image committed to ID: " + Image.ID)
					}
				}
			} else {
				log.Error(2, "You haven't defined at least a repository to commit in inside your configuration file")
			}
		}
		client.RemoveContainer(docker.RemoveContainerOptions{
			ID:    container.ID,
			Force: true,
		})
	}()
	if err != nil {
		log.Error(2, "Failed: %v", err)
	}
	log.Info("Starting container: " + container.ID)
	volumes = append(volumes, config.Volumes...)
	err = client.StartContainer(container.ID, &docker.HostConfig{Binds: volumes, LogConfig: docker.LogConfig{Type: "json-file"}})
	if err != nil {
		log.Error(2, "Failed: %v", err)
		return false, err
	}
	status, err = client.WaitContainer(container.ID)
	container, err = client.InspectContainer(container.ID) // update our container information
	if err != nil {
		log.Error(2, "Failed: %v", err)
	}

	logfile := config.LogDir + "/" + head + ".json"
	log.Info("Copying " + container.LogPath + " to " + logfile)
	err = CopyFileContents(container.LogPath, logfile)
	os.Chmod(logfile, os.FileMode(config.LogPerm))
	if err != nil {
		log.Error(2, "Failed: %v", err)
	}

	if status == int(0) {
		return true, err
	}
	return false, err

}
